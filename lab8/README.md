# Car Inventory API

## Описание

Это веб-приложение на Flask для управления автопарком с использованием микросервисной архитектуры и асинхронной обработки событий через Kafka.

## Архитектура

Проект состоит из следующих компонентов:

### 1. Flask-приложение (`app.py`)
- Основной веб-сервер, обрабатывающий HTTP-запросы
- Реализует CRUD-операции для автомобилей (создание, чтение, обновление, удаление)
- Использует PostgreSQL для хранения данных
- Использует Redis для кэширования

### 2. Kafka Producer
- Отправляет события в Kafka при выполнении операций с автомобилями
- События включают: создание, обновление и удаление автомобилей

### 3. Kafka Consumer (`consumer.py`)
- Отдельный сервис, обрабатывающий события из Kafka
- Обрабатывает сообщения об изменениях в автопарке

### 4. Базы данных
- **PostgreSQL**: основное хранилище данных об автомобилях
- **Redis**: кэш для ускорения чтения данных

### 5. Асинхронная обработка (Kafka)
Для понимания Kafka, представьте это как систему учета в автосалоне:

- **Producer (производитель)** - это человек, который добавляет автомобили в систему. Когда вы добавляете, изменяете или удаляете автомобиль в приложении, Flask-приложение создает "сообщение" (например, "добавлен автомобиль Toyota Camry") и кладет его в "почтовый ящик" Kafka.

- **Topic (тема)** - это как ящик для определенного типа писем. У нас есть тема `car_events` - это ящик, куда попадают все события, связанные с автомобилями.

- **Consumer (потребитель)** - это работник автосалона, который проверяет почтовый ящик и обрабатывает каждое сообщение. `consumer.py` - это как работник, который читает сообщения из Kafka и делает что-то с ними (например, записывает в журнал, отправляет уведомление и т.д.).

Пример из жизни:
- Вы добавляете автомобиль "Toyota Camry" в автопарк через веб-интерфейс
- Flask-приложение создает сообщение: "новый автомобиль добавлен: Toyota Camry"
- Это сообщение попадает в Kafka (как письмо в почтовый ящик)
- Consumer (работник) читает это сообщение и, например, отправляет уведомление менеджеру

**Dead Letter Queue (DLQ)** - это как "черный ящик" для сообщений, которые не удалось обработать. Если сообщение о создании автомобиля не получилось обработать, оно попадает в специальный ящик `dead_letter_events` для дальнейшего разбора.

Все это работает асинхронно - то есть Flask-приложение не ждет, пока consumer обработает сообщение, а продолжает работать дальше. Это делает систему более устойчивой и быстрой.

## Файлы проекта

- `app.py` - основное Flask-приложение
- `consumer.py` - обработчик Kafka-событий
- `Dockerfile` - инструкции для создания Docker-образа
- `docker-compose.yml` - оркестрация контейнеров
- `requirements.txt` - зависимости Python
- `.env` - переменные окружения

## Запуск

Для запуска проекта используйте Docker Compose:

```bash
docker-compose up --build
```

Приложение будет доступно по адресу `http://localhost:5000`

## API endpoints

- `GET /` - информация об API
- `GET /cars` - получить все автомобили
- `GET /cars/<id>` - получить автомобиль по ID
- `POST /cars` - создать новый автомобиль
- `PUT /cars/<id>` - обновить автомобиль
- `DELETE /cars/<id>` - удалить автомобиль
- `GET /stats` - статистика запросов
- `GET /health` - проверка состояния сервисов